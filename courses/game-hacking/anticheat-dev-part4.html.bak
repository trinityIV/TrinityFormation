<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trinity - Protection du Code Anti-Cheat</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body class="bg-dark text-light">
    <!-- Placeholder pour la navigation -->
    <div id="navigation-placeholder"></div>

    <main class="container mt-5 pt-5">
        <!-- En-tête du cours -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="card bg-dark border-primary">
                    <div class="card-body">
                        <h1 class="card-title text-primary">Protection du Code Anti-Cheat</h1>
                        <div class="d-flex align-items-center mb-3">
                            <span class="badge bg-primary me-2">Partie 4/5</span>
                            <span class="badge bg-info me-2">Durée: 12h</span>
                            <span class="badge bg-success">Game Hacking</span>
                        </div>
                        <p class="card-text">Apprenez à protéger le code de votre anti-cheat contre la rétro-ingénierie et les modifications malveillantes. Cette partie couvre l'obfuscation, la virtualisation, et les techniques anti-tampering avancées.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Barre de progression -->
        <div class="progress mb-4" style="height: 30px;">
            <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%" id="courseProgress"></div>
        </div>
        <!-- Contenu du cours -->
        <div class="row">
            <!-- Table des matières -->
            <div class="col-md-3">
                <div class="card bg-dark border-secondary position-sticky" style="top: 100px;">
                    <div class="card-body">
                        <h5 class="card-title text-secondary">Table des matières</h5>
                        <nav id="toc" class="nav flex-column">
                            <a class="nav-link" href="#code-obfuscation">1. Obfuscation du Code</a>
                            <a class="nav-link" href="#virtualization">2. Virtualisation</a>
                            <a class="nav-link" href="#anti-tampering">3. Anti-Tampering</a>
                            <a class="nav-link" href="#integrity-checks">4. Vérifications d'Intégrité</a>
                            <a class="nav-link" href="#implementation">5. Implémentation</a>
                        </nav>
                    </div>
                </div>
            </div>
            <!-- Contenu principal -->
            <div class="col-md-9">
                <section id="code-obfuscation" class="mb-5">
                    <h2 class="text-primary">1. Obfuscation du Code</h2>
                    <div class="card bg-dark border-secondary mb-4">
                        <div class="card-body">
                            <h3>Techniques d'Obfuscation</h3>
                            <div class="alert alert-info mb-3">
                                <i class="fas fa-mask"></i> Protection contre l'analyse statique :
                            </div>
                            <pre><code class="language-cpp">class CodeObfuscator {
private:
    // Clé de chiffrement unique par build
    static constexpr uint32_t BUILD_KEY = 0x__RANDOM__;
    
    template<typename T>
    static T ObfuscateConstant(T value) {
        return value ^ BUILD_KEY;
    }
    
    // Macro pour obfusquer les chaînes
    #define OBFUSCATE_STR(str) \
        StringObfuscator<sizeof(str)>(str, BUILD_KEY)
        
public:
    template<size_t N>
    class StringObfuscator {
    private:
        char data[N];
        
    public:
        constexpr StringObfuscator(
            const char* str,
            uint32_t key
        ) {
            for (size_t i = 0; i < N; i++) {
                data[i] = str[i] ^ (key & 0xFF);
                key = RotateRight(key, 8);
            }
        }
        
        std::string Decrypt() const {
            std::string result;
            result.reserve(N);
            
            uint32_t key = BUILD_KEY;
            for (size_t i = 0; i < N; i++) {
                result += data[i] ^ (key & 0xFF);
                key = RotateRight(key, 8);
            }
            
            return result;
        }
    };
    
    // Obfuscation du flux de contrôle
    template<typename Func>
    static void ObfuscateFunction(Func& func) {
        // Ajouter des blocs factices
        if (GetRandomBool()) {
            ExecuteFakeBlock();
        }
        
        // Exécuter la fonction
        func();
        
        // Mélanger l'ordre d'exécution
        if (GetRandomBool()) {
            ExecutePostBlock();
        }
    }
};</code></pre>
                        </div>
                    </div>
                </section>

                <section id="virtualization" class="mb-5">
                    <h2 class="text-primary">2. Virtualisation</h2>
                    <div class="card bg-dark border-secondary mb-4">
                        <div class="card-body">
                            <h3>Machine Virtuelle Personnalisée</h3>
                            <div class="alert alert-warning mb-3">
                                <i class="fas fa-microchip"></i> Protection par virtualisation du code :
                            </div>
                            <pre><code class="language-cpp">class CustomVM {
private:
    struct VMContext {
        uint64_t registers[16];
        uint8_t* codePtr;
        uint8_t* stackPtr;
        bool running;
    };
    
    enum class VMOpcode : uint8_t {
        MOV_REG_IMM = 0x01,
        ADD_REG_REG = 0x02,
        XOR_REG_IMM = 0x03,
        CALL_NATIVE = 0x04,
        JMP_COND    = 0x05,
        RET         = 0xFF
    };
    
    VMContext ctx;
    std::vector<uint8_t> virtualizedCode;
    
public:
    void InitializeVM() {
        ctx.running = true;
        ctx.codePtr = virtualizedCode.data();
        // Initialiser registres et stack
    }
    
    void ExecuteVM() {
        while (ctx.running) {
            VMOpcode opcode = ReadOpcode();
            switch (opcode) {
                case VMOpcode::MOV_REG_IMM:
                    ExecuteMoveImmediate();
                    break;
                    
                case VMOpcode::ADD_REG_REG:
                    ExecuteAddRegisters();
                    break;
                    
                case VMOpcode::XOR_REG_IMM:
                    ExecuteXorImmediate();
                    break;
                    
                case VMOpcode::CALL_NATIVE:
                    ExecuteNativeCall();
                    break;
                    
                case VMOpcode::JMP_COND:
                    ExecuteConditionalJump();
                    break;
                    
                case VMOpcode::RET:
                    ctx.running = false;
                    break;
            }
        }
    }
    
private:
    VMOpcode ReadOpcode() {
        VMOpcode op = *reinterpret_cast<VMOpcode*>(
            ctx.codePtr++);
        // Déchiffrer l'opcode
        return static_cast<VMOpcode>(
            static_cast<uint8_t>(op) ^ BUILD_KEY);
    }
};</code></pre>
                        </div>
                    </div>
                </section>
                <section id="anti-tampering" class="mb-5">
                    <h2 class="text-primary">3. Anti-Tampering</h2>
                    <div class="card bg-dark border-secondary mb-4">
                        <div class="card-body">
                            <h3>Protection contre les Modifications</h3>
                            <div class="alert alert-danger mb-3">
                                <i class="fas fa-shield-alt"></i> Détection des modifications de code :
                            </div>
                            <pre><code class="language-cpp">class AntiTampering {
private:
    struct CodeSection {
        void* start;
        size_t size;
        uint32_t checksum;
    };
    
    std::vector<CodeSection> protectedSections;
    
public:
    void ProtectSection(
        void* start,
        size_t size
    ) {
        CodeSection section;
        section.start = start;
        section.size = size;
        
        // Calculer checksum initial
        section.checksum = CalculateChecksum(
            start, size);
            
        // Protéger la mémoire
        DWORD oldProtect;
        VirtualProtect(start, size,
            PAGE_EXECUTE_READ, &oldProtect);
            
        protectedSections.push_back(section);
    }
    
    bool VerifyIntegrity() {
        for (const auto& section : protectedSections) {
            uint32_t currentChecksum = 
                CalculateChecksum(
                    section.start,
                    section.size
                );
                
            if (currentChecksum != section.checksum)
                return false;
        }
        return true;
    }
    
private:
    uint32_t CalculateChecksum(
        void* data,
        size_t size
    ) {
        // Algorithme personnalisé de checksum
        const uint8_t* bytes = 
            static_cast<uint8_t*>(data);
        uint32_t checksum = 0;
        
        for (size_t i = 0; i < size; i++) {
            checksum = RotateLeft(checksum, 7);
            checksum ^= bytes[i];
            checksum += BUILD_KEY;
        }
        
        return checksum;
    }
};</code></pre>
                        </div>
                    </div>
                </section>

                <section id="integrity-checks" class="mb-5">
                    <h2 class="text-primary">4. Vérifications d'Intégrité</h2>
                    <div class="card bg-dark border-secondary mb-4">
                        <div class="card-body">
                            <h3>Vérifications en Temps Réel</h3>
                            <pre><code class="language-cpp">class IntegrityChecker {
private:
    struct CheckPoint {
        void* address;
        size_t size;
        std::vector<uint8_t> originalBytes;
        std::function<void()> callback;
    };
    
    std::vector<CheckPoint> checkPoints;
    std::thread checkerThread;
    std::atomic<bool> running;
    
public:
    void AddCheckPoint(
        void* address,
        size_t size,
        std::function<void()> callback
    ) {
        CheckPoint point;
        point.address = address;
        point.size = size;
        point.callback = callback;
        
        // Sauvegarder état original
        point.originalBytes.resize(size);
        memcpy(point.originalBytes.data(),
            address, size);
            
        checkPoints.push_back(point);
    }
    
    void StartChecking() {
        running = true;
        checkerThread = std::thread([this]() {
            while (running) {
                for (const auto& point : checkPoints) {
                    if (!VerifyCheckPoint(point)) {
                        // Exécuter callback sur violation
                        point.callback();
                    }
                }
                
                // Délai aléatoire entre vérifications
                std::this_thread::sleep_for(
                    std::chrono::milliseconds(
                        GetRandomDelay()));
            }
        });
    }
    
private:
    bool VerifyCheckPoint(
        const CheckPoint& point
    ) {
        std::vector<uint8_t> currentBytes(
            point.size);
        memcpy(currentBytes.data(),
            point.address, point.size);
            
        return currentBytes == 
            point.originalBytes;
    }
    
    uint32_t GetRandomDelay() {
        // 100-500ms
        return 100 + (rand() % 400);
    }
};</code></pre>
                        </div>
                    </div>
                </section>
                <section id="implementation" class="mb-5">
                    <h2 class="text-primary">5. Implémentation</h2>
                    <div class="card bg-dark border-secondary mb-4">
                        <div class="card-body">
                            <h3>Système de Protection Complet</h3>
                            <div class="alert alert-success mb-4">
                                <i class="fas fa-shield-alt"></i> Implémentation d'un système de protection du code complet
                            </div>
                            <pre><code class="language-cpp">class CodeProtectionSystem {
private:
    CodeObfuscator obfuscator;
    CustomVM virtualMachine;
    AntiTampering antiTampering;
    IntegrityChecker integrityChecker;
    
    // Sections critiques à protéger
    struct CriticalSection {
        void* address;
        size_t size;
        bool virtualize;
    };
    
    std::vector<CriticalSection> criticalSections;
    
public:
    bool Initialize() {
        // 1. Identifier sections critiques
        IdentifyCriticalSections();
        
        // 2. Appliquer obfuscation
        for (const auto& section : criticalSections) {
            if (section.virtualize) {
                // Virtualiser le code
                virtualMachine.VirtualizeCode(
                    section.address,
                    section.size
                );
            } else {
                // Obfusquer le code
                obfuscator.ObfuscateSection(
                    section.address,
                    section.size
                );
            }
        }
        
        // 3. Configurer anti-tampering
        for (const auto& section : criticalSections) {
            antiTampering.ProtectSection(
                section.address,
                section.size
            );
        }
        
        // 4. Configurer vérifications d'intégrité
        SetupIntegrityChecks();
        
        return true;
    }
    
private:
    void SetupIntegrityChecks() {
        // Ajouter points de vérification
        for (const auto& section : criticalSections) {
            integrityChecker.AddCheckPoint(
                section.address,
                section.size,
                [this]() {
                    OnIntegrityViolation();
                }
            );
        }
        
        // Démarrer thread de vérification
        integrityChecker.StartChecking();
    }
    
    void OnIntegrityViolation() {
        // 1. Logger l'incident
        LogViolation();
        
        // 2. Notifier le serveur
        ReportViolation();
        
        // 3. Actions de protection
        EmergencyActions();
    }
    
    void EmergencyActions() {
        // 1. Corrompre la mémoire du jeu
        CorruptGameMemory();
        
        // 2. Désactiver fonctionnalités
        DisableGameFeatures();
        
        // 3. Terminer proprement
        InitiateShutdown();
    }
};</code></pre>
                            <div class="alert alert-info mt-3">
                                <i class="fas fa-lightbulb"></i> Ce système combine toutes les techniques vues dans cette partie pour une protection complète du code anti-cheat.
                            </div>
                            <div class="alert alert-warning mt-3">
                                <i class="fas fa-exclamation-triangle"></i> Important : Ces techniques doivent être utilisées de manière éthique et légale, uniquement pour protéger votre propre code contre la triche.
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </main>
    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="../../js/include-nav.js"></script>
    <script>
        function updateProgress() {
            const sections = document.querySelectorAll('section');
            const windowHeight = window.innerHeight;
            let totalSections = sections.length;
            let completedSections = 0;

            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top < windowHeight * 0.75) {
                    completedSections++;
                }
            });

            const progress = (completedSections / totalSections) * 100;
            document.getElementById('courseProgress').style.width = progress + '%';
        }

        window.addEventListener('scroll', updateProgress);
        updateProgress();
    </script>
</body>
</html>
