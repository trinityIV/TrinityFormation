<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trinity - Java Avancé</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body><div id="navigation-placeholder"></div>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="../../index.html">Trinity</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="../../index.html">Accueil</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle active" href="#" role="button" data-bs-toggle="dropdown">
                            Programming
                        </a>
                        <ul class="dropdown-menu">
                            <li><h6 class="dropdown-header">Java</h6></li>
                            <li><a class="dropdown-item" href="java-basics.html">Bases Java</a></li>
                            <li><a class="dropdown-item active" href="java-advanced.html">Java Avancé</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Background Canvas -->
    <canvas id="background-canvas"></canvas>

    <!-- Main Content -->
    <div class="container mt-5 pt-5">
        <h1 class="text-center mb-5">Cours : Java Avancé</h1>

        <!-- Course Progress -->
        <div class="progress mb-4" style="height: 30px;">
            <div class="progress-bar bg-success" role="progressbar" style="width: 0%;" 
                 aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                0% Complété
            </div>
        </div>

        <!-- Reflection -->
        <section class="mb-5 content-section" id="reflection">
            <h2>Reflection et Métaprogrammation</h2>
            <div class="card">
                <div class="card-body">
                    <h3>Inspection de Classes</h3>
                    <pre><code class="java">public class ReflectionExample {
    public static void inspectClass(Class<?> clazz) {
        System.out.println("Class: " + clazz.getName());
        
        // Méthodes
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            System.out.println("Method: " + method.getName());
            System.out.println("  Return: " + method.getReturnType());
            System.out.println("  Params: " + Arrays.toString(method.getParameterTypes()));
        }
        
        // Fields
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            System.out.println("Field: " + field.getName());
            System.out.println("  Type: " + field.getType());
        }
    }
}</code></pre>

                    <h3>Manipulation Dynamique</h3>
                    <pre><code class="java">public class DynamicInvocation {
    public static Object invokeMethod(Object obj, String methodName, Object... args) 
            throws Exception {
        Class<?>[] paramTypes = new Class<?>[args.length];
        for (int i = 0; i < args.length; i++) {
            paramTypes[i] = args[i].getClass();
        }
        
        Method method = obj.getClass().getDeclaredMethod(methodName, paramTypes);
        method.setAccessible(true);
        return method.invoke(obj, args);
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Bytecode Manipulation -->
        <section class="mb-5 content-section" id="bytecode">
            <h2>Manipulation de Bytecode</h2>
            <div class="card">
                <div class="card-body">
                    <h3>ASM Framework</h3>
                    <pre><code class="java">public class BytecodeManipulator extends ClassVisitor {
    public BytecodeManipulator(ClassVisitor cv) {
        super(Opcodes.ASM9, cv);
    }
    
    @Override
    public MethodVisitor visitMethod(int access, String name, 
            String desc, String signature, String[] exceptions) {
        MethodVisitor mv = super.visitMethod(access, name, 
                desc, signature, exceptions);
        
        // Ajouter du logging
        if (name.equals("targetMethod")) {
            return new LoggingMethodAdapter(mv);
        }
        return mv;
    }
}

class LoggingMethodAdapter extends MethodVisitor {
    public LoggingMethodAdapter(MethodVisitor mv) {
        super(Opcodes.ASM9, mv);
    }
    
    @Override
    public void visitCode() {
        // Ajouter System.out.println avant l'exécution
        mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", 
                "Ljava/io/PrintStream;");
        mv.visitLdcInsn("Method called");
        mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", 
                "println", "(Ljava/lang/String;)V", false);
        super.visitCode();
    }
}</code></pre>

                    <h3>Javassist</h3>
                    <pre><code class="java">public class JavassistExample {
    public static void addLogging(String className, String methodName) 
            throws Exception {
        ClassPool pool = ClassPool.getDefault();
        CtClass cc = pool.get(className);
        CtMethod method = cc.getDeclaredMethod(methodName);
        
        method.insertBefore(
            "System.out.println(\"Entering method: " + methodName + "\");"
        );
        method.insertAfter(
            "System.out.println(\"Exiting method: " + methodName + "\");"
        );
        
        cc.writeFile();
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- JVM Internals -->
        <section class="mb-5 content-section" id="jvm">
            <h2>Internals de la JVM</h2>
            <div class="card">
                <div class="card-body">
                    <h3>Agents Java</h3>
                    <pre><code class="java">public class JavaAgent {
    public static void premain(String args, Instrumentation inst) {
        inst.addTransformer(new ClassFileTransformer() {
            @Override
            public byte[] transform(ClassLoader loader, String className,
                    Class<?> classBeingRedefined,
                    ProtectionDomain protectionDomain,
                    byte[] classfileBuffer) {
                // Modification du bytecode
                return modifyClass(classfileBuffer);
            }
        });
    }
}</code></pre>

                    <h3>Attachement à la JVM</h3>
                    <pre><code class="java">public class JVMAttacher {
    public static void attach(String pid) throws Exception {
        VirtualMachine vm = VirtualMachine.attach(pid);
        try {
            vm.loadAgent("path/to/agent.jar");
        } finally {
            vm.detach();
        }
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Memory Analysis -->
        <section class="mb-5 content-section" id="memory">
            <h2>Analyse de la Mémoire</h2>
            <div class="card">
                <div class="card-body">
                    <h3>Heap Dumping</h3>
                    <pre><code class="java">public class HeapAnalyzer {
    public static void dumpHeap(String filePath, boolean live) 
            throws Exception {
        MBeanServer server = ManagementFactory.getPlatformMBeanServer();
        HotSpotDiagnosticMXBean mxBean = ManagementFactory.
            newPlatformMXBeanProxy(server,
                "com.sun.management:type=HotSpotDiagnostic",
                HotSpotDiagnosticMXBean.class);
        mxBean.dumpHeap(filePath, live);
    }
}</code></pre>

                    <h3>Memory Leaks Detection</h3>
                    <pre><code class="java">public class MemoryLeakDetector {
    private static final Map<Object, WeakReference<Object>> objects = 
        new ConcurrentHashMap<>();
    
    public static void track(Object obj) {
        objects.put(obj, new WeakReference<>(obj));
    }
    
    public static List<Object> findLeaks() {
        System.gc();
        List<Object> leaks = new ArrayList<>();
        
        for (Map.Entry<Object, WeakReference<Object>> entry : 
                objects.entrySet()) {
            if (entry.getValue().get() == null) {
                leaks.add(entry.getKey());
            }
        }
        return leaks;
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Network Security -->
        <section class="mb-5 content-section" id="network">
            <h2>Sécurité Réseau</h2>
            <div class="card">
                <div class="card-body">
                    <h3>Packet Sniffer</h3>
                    <pre><code class="java">public class PacketSniffer {
    private static final int SNAPLEN = 65536;
    private static final int TIMEOUT = 1000;
    
    public void startCapture(String device) throws Exception {
        NetworkInterface nif = NetworkInterface.getByName(device);
        PcapNetworkInterface pnif = Pcaps.getDevByName(device);
        
        try (PcapHandle handle = pnif.openLive(SNAPLEN, 
                PcapNetworkInterface.PromiscuousMode.PROMISCUOUS, 
                TIMEOUT)) {
            
            handle.loop(-1, new PacketListener() {
                @Override
                public void gotPacket(Packet packet) {
                    if (packet.contains(TcpPacket.class)) {
                        TcpPacket tcpPacket = packet.get(TcpPacket.class);
                        System.out.println("Source port: " + 
                            tcpPacket.getHeader().getSrcPort());
                        System.out.println("Dest port: " + 
                            tcpPacket.getHeader().getDstPort());
                    }
                }
            });
        }
    }
}</code></pre>

                    <h3>SSL/TLS Interceptor</h3>
                    <pre><code class="java">public class SSLInterceptor {
    private SSLContext sslContext;
    
    public void setupProxy(int port) throws Exception {
        // Création d'un certificat auto-signé
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(2048);
        KeyPair keyPair = keyGen.generateKeyPair();
        
        // Configuration du contexte SSL
        sslContext = SSLContext.getInstance("TLS");
        sslContext.init(
            new KeyManager[] { createKeyManager(keyPair) },
            new TrustManager[] { createTrustManager() },
            new SecureRandom()
        );
        
        // Démarrage du proxy
        ServerSocket serverSocket = 
            sslContext.getServerSocketFactory().createServerSocket(port);
        // Handling des connexions...
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Android Security -->
        <section class="mb-5 content-section" id="android">
            <h2>Sécurité Android</h2>
            <div class="card">
                <div class="card-body">
                    <h3>APK Analysis</h3>
                    <pre><code class="java">public class APKAnalyzer {
    public void analyzeAPK(String apkPath) throws Exception {
        ApkFile apkFile = new ApkFile(new File(apkPath));
        
        // Analyse du manifest
        String manifest = apkFile.getManifestXml();
        System.out.println("Permissions: " + 
            extractPermissions(manifest));
        
        // Analyse des classes
        DexFile dexFile = new DexFile(apkFile.getBytes("classes.dex"));
        for (ClassDef classDef : dexFile.getClasses()) {
            analyzeClass(classDef);
        }
    }
    
    private void analyzeClass(ClassDef classDef) {
        // Recherche de vulnérabilités courantes
        for (Method method : classDef.getMethods()) {
            checkForVulnerabilities(method);
        }
    }
}</code></pre>

                    <h3>Runtime Hooking</h3>
                    <pre><code class="java">public class AndroidHooker {
    public void hookMethod(String className, String methodName) {
        XposedHelpers.findAndHookMethod(
            className,
            null,
            methodName,
            new XC_MethodHook() {
                @Override
                protected void beforeHookedMethod(MethodHookParam param) 
                        throws Throwable {
                    System.out.println("Before " + methodName);
                    System.out.println("Args: " + 
                        Arrays.toString(param.args));
                }
                
                @Override
                protected void afterHookedMethod(MethodHookParam param) 
                        throws Throwable {
                    System.out.println("After " + methodName);
                    System.out.println("Result: " + param.getResult());
                }
            }
        );
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Practical Exercise -->
        <section class="mb-5 content-section" id="exercise">
            <h2>Exercice Pratique</h2>
            <div class="card">
                <div class="card-body">
                    <h3>Projet : Framework d'Analyse d'Applications Android</h3>
                    <p>Créez un framework d'analyse statique et dynamique d'applications Android avec :</p>
                    <ul>
                        <li>Décompilation et analyse d'APK</li>
                        <li>Détection de vulnérabilités courantes</li>
                        <li>Hooking d'API sensibles</li>
                        <li>Analyse du trafic réseau</li>
                        <li>Rapport d'analyse détaillé</li>
                    </ul>

                    <div class="alert alert-info">
                        <strong>Conseil :</strong> Utilisez les concepts avancés vus dans le cours : reflection pour l'analyse dynamique, bytecode manipulation pour l'instrumentation, et JVM internals pour le hooking.
                    </div>

                    <div class="alert alert-warning">
                        <strong>Note :</strong> Ce projet doit être utilisé uniquement dans un environnement de test contrôlé et à des fins éducatives.
                    </div>
                </div>
            </div>
        </section>
    </div>

    <footer class="text-center py-4">
        <p>Trinity Project © 2025 - Cours Java Avancé</p>
    </footer>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="../../js/main.js"></script>
    <script>
        // Gestion de la progression
        function updateProgress() {
            const sections = document.querySelectorAll('.content-section');
            const progressBar = document.querySelector('.progress-bar');
            const completed = Math.round((Array.from(sections).filter(section => 
                section.getBoundingClientRect().top < window.innerHeight/2).length / sections.length) * 100);
            progressBar.style.width = completed + '%';
            progressBar.textContent = completed + '% Complété';
            progressBar.setAttribute('aria-valuenow', completed);
        }

        // Mise à jour de la progression au scroll
        window.addEventListener('scroll', updateProgress);
        updateProgress();
    </script>
<script src="../../js/background.js"></script><script src="../../js/navigation.js"></script></body>
</html>

